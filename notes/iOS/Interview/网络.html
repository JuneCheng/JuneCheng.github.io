<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络 | JuneCheng&#39;s 技术博客</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.495d9abf.css" as="style"><link rel="preload" href="/assets/js/app.d120e625.js" as="script"><link rel="preload" href="/assets/js/2.4ddb53c8.js" as="script"><link rel="preload" href="/assets/js/24.ed65da7c.js" as="script"><link rel="prefetch" href="/assets/js/10.eec581a8.js"><link rel="prefetch" href="/assets/js/11.b8b5e20a.js"><link rel="prefetch" href="/assets/js/12.3f826545.js"><link rel="prefetch" href="/assets/js/13.547d67da.js"><link rel="prefetch" href="/assets/js/14.c84675f7.js"><link rel="prefetch" href="/assets/js/15.5f740f5c.js"><link rel="prefetch" href="/assets/js/16.d51cd5b2.js"><link rel="prefetch" href="/assets/js/17.47d53a8f.js"><link rel="prefetch" href="/assets/js/18.da82b46e.js"><link rel="prefetch" href="/assets/js/19.12f7db1b.js"><link rel="prefetch" href="/assets/js/20.52ce7371.js"><link rel="prefetch" href="/assets/js/21.3a9bde28.js"><link rel="prefetch" href="/assets/js/22.645e3571.js"><link rel="prefetch" href="/assets/js/23.a627903e.js"><link rel="prefetch" href="/assets/js/25.9990f3ee.js"><link rel="prefetch" href="/assets/js/26.0dc1db3f.js"><link rel="prefetch" href="/assets/js/27.b56dbd06.js"><link rel="prefetch" href="/assets/js/28.b8ab46ee.js"><link rel="prefetch" href="/assets/js/29.899bf0b6.js"><link rel="prefetch" href="/assets/js/3.ea6815ce.js"><link rel="prefetch" href="/assets/js/30.79e57cd2.js"><link rel="prefetch" href="/assets/js/31.34f199c9.js"><link rel="prefetch" href="/assets/js/32.a8f83636.js"><link rel="prefetch" href="/assets/js/33.b1365941.js"><link rel="prefetch" href="/assets/js/34.bf23bd1f.js"><link rel="prefetch" href="/assets/js/35.348ce2a5.js"><link rel="prefetch" href="/assets/js/36.b2bd70d8.js"><link rel="prefetch" href="/assets/js/37.7f846fb3.js"><link rel="prefetch" href="/assets/js/38.f54aa3bf.js"><link rel="prefetch" href="/assets/js/4.a748f09b.js"><link rel="prefetch" href="/assets/js/5.c37bdb01.js"><link rel="prefetch" href="/assets/js/6.c9c7a850.js"><link rel="prefetch" href="/assets/js/7.4e5434ba.js"><link rel="prefetch" href="/assets/js/8.91f58f85.js"><link rel="prefetch" href="/assets/js/9.ccf89b6a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.495d9abf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">JuneCheng's 技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><span class="title">iOS</span> <span class="arrow down"></span></button> <button type="button" aria-label="iOS" class="mobile-dropdown-title"><span class="title">iOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/iOS/Interview/" class="nav-link router-link-active">
  Interview
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/个人技术文档/" class="nav-link">
  个人技术文档
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/工具安装指南/" class="nav-link">
  工具安装指南
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/算法/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/notes/android/" class="nav-link">
  Android
</a></div><div class="nav-item"><a href="/notes/VUE/" class="nav-link">
  VUE
</a></div><div class="nav-item"><a href="/notes/Flutter/" class="nav-link">
  Flutter
</a></div><div class="nav-item"><a href="https://github.com/JuneCheng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><span class="title">iOS</span> <span class="arrow down"></span></button> <button type="button" aria-label="iOS" class="mobile-dropdown-title"><span class="title">iOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/iOS/Interview/" class="nav-link router-link-active">
  Interview
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/个人技术文档/" class="nav-link">
  个人技术文档
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/工具安装指南/" class="nav-link">
  工具安装指南
</a></li><li class="dropdown-item"><!----> <a href="/notes/iOS/算法/" class="nav-link">
  算法
</a></li></ul></div></div><div class="nav-item"><a href="/notes/android/" class="nav-link">
  Android
</a></div><div class="nav-item"><a href="/notes/VUE/" class="nav-link">
  VUE
</a></div><div class="nav-item"><a href="/notes/Flutter/" class="nav-link">
  Flutter
</a></div><div class="nav-item"><a href="https://github.com/JuneCheng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/iOS/Interview/" aria-current="page" class="sidebar-link">关于Interview</a></li><li><a href="/notes/iOS/Interview/Block.html" class="sidebar-link">Block</a></li><li><a href="/notes/iOS/Interview/Runloop.html" class="sidebar-link">Runloop</a></li><li><a href="/notes/iOS/Interview/Runtime.html" class="sidebar-link">Runtime</a></li><li><a href="/notes/iOS/Interview/SDK开发.html" class="sidebar-link">SDK开发</a></li><li><a href="/notes/iOS/Interview/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/notes/iOS/Interview/三方库相关.html" class="sidebar-link">三方库相关</a></li><li><a href="/notes/iOS/Interview/基础.html" class="sidebar-link">基础</a></li><li><a href="/notes/iOS/Interview/多线程.html" class="sidebar-link">多线程</a></li><li><a href="/notes/iOS/Interview/底层原理.html" class="sidebar-link">底层原理</a></li><li><a href="/notes/iOS/Interview/性能优化.html" class="sidebar-link">性能优化</a></li><li><a href="/notes/iOS/Interview/结构体.html" class="sidebar-link">结构体</a></li><li><a href="/notes/iOS/Interview/网络.html" class="active sidebar-link">网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#app-网络层有哪些优化策略" class="sidebar-link">App 网络层有哪些优化策略</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#https的加密原理" class="sidebar-link">HTTPS的加密原理</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#https中客户端验证公钥证书的过程" class="sidebar-link">https中客户端验证公钥证书的过程</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#数据安全及各种加密算法对比" class="sidebar-link">数据安全及各种加密算法对比</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#http协议包含那些内容" class="sidebar-link">http协议包含那些内容</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#http-1-0-1-1-2-0-3-0的特点及其区别" class="sidebar-link">http 1.0 1.1 2.0 3.0的特点及其区别</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#http请求头中各字段解释" class="sidebar-link">HTTP请求头中各字段解释</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#tcp和udp的区别和优缺点" class="sidebar-link">TCP和UDP的区别和优缺点</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#tcp三次握手和四次挥手全过程及为什么要三次握手解答" class="sidebar-link">TCP三次握手和四次挥手全过程及为什么要三次握手解答</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#为什么不能两次握手-防止已失效的连接请求又传送到服务器端-因而产生错误" class="sidebar-link">为什么不能两次握手：防止已失效的连接请求又传送到服务器端，因而产生错误</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#syn攻击" class="sidebar-link">SYN攻击：</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#cookie-和-session-的区别" class="sidebar-link">Cookie 和 Session 的区别：</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#osi七层协议模型、tcp-ip四层模型" class="sidebar-link">OSI七层协议模型、TCP/IP四层模型</a></li><li class="sidebar-sub-header"><a href="/notes/iOS/Interview/网络.html#afnetworking-底层原理分析" class="sidebar-link">AFNetworking 底层原理分析</a></li></ul></li><li><a href="/notes/iOS/Interview/逆向.html" class="sidebar-link">逆向</a></li><li><a href="/notes/iOS/Interview/项目架构.html" class="sidebar-link">项目架构</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h1> <h2 id="app-网络层有哪些优化策略"><a href="#app-网络层有哪些优化策略" class="header-anchor">#</a> App 网络层有哪些优化策略</h2> <ul><li><ol><li>优化DNS解析和缓存</li></ol></li> <li><ol start="2"><li>对传输的数据进行压缩，减少传输的数据</li></ol></li> <li><ol start="3"><li>使用缓存手段减少请求的发起次数</li></ol></li> <li><ol start="4"><li>使用策略来减少请求的发起次数，比如在上一个请求未着地之前，不进行新的请求</li></ol></li> <li><ol start="5"><li>避免网络抖动，提供重发机制</li></ol></li></ul> <h2 id="https的加密原理"><a href="#https的加密原理" class="header-anchor">#</a> HTTPS的加密原理</h2> <ul><li><ol><li>服务器端用非对称加密(RSA)生成公钥和私钥或者跟CA机构购买证书</li></ol></li> <li><ol start="2"><li>客户端发送请求，服务端把公钥发给客户端, 服务器则保存私钥</li></ol></li> <li><ol start="3"><li>客户端拿到公钥，验证证书可信任后会生成一个随机密钥, 这个随机密钥就是将来客户端和服务器用来通信的钥匙</li></ol></li> <li><ol start="4"><li>然后客户端用公钥对随机密钥进行加密, 再发给服务器</li></ol></li> <li><ol start="5"><li>服务器拿到客户端发来的加密后的密钥后, 再使用私钥解密密钥, 到此双方都获得通信的钥匙</li></ol></li></ul> <h2 id="https中客户端验证公钥证书的过程"><a href="#https中客户端验证公钥证书的过程" class="header-anchor">#</a> https中客户端验证公钥证书的过程</h2> <p><a href="https://juejin.cn/post/6844903924760068103" target="_blank" rel="noopener noreferrer">参考文献<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>服务器将公钥证书发送给客户端 客户端验证公钥证书 从而确保公钥的合法性</p> <ul><li><ol><li>客户端取出提前内置在手机内部的认证机构的公钥</li></ol></li> <li><ol start="2"><li>用认证机构的公钥去解密公钥证书里的数字签名 从而得到数字指纹</li></ol></li> <li><ol start="3"><li>客户端对公钥证书的服务器公钥进行 数字摘要算法 从而生成数字指纹</li></ol></li> <li><ol start="4"><li>对比客户端自己生成的数字指纹(第3步)和解密得到的数字指纹(第2步)是否一致 如果一致则公钥证书验证通过 就可以进行接下来的握手步骤了</li></ol></li></ul> <h2 id="数据安全及各种加密算法对比"><a href="#数据安全及各种加密算法对比" class="header-anchor">#</a> 数据安全及各种加密算法对比</h2> <p><a href="https://www.jianshu.com/p/b44927161081" target="_blank" rel="noopener noreferrer">参考文献<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="http协议包含那些内容"><a href="#http协议包含那些内容" class="header-anchor">#</a> http协议包含那些内容</h2> <ul><li><p>http协议 包含  http协议的请求和http协议的响应</p></li> <li><p>http协议的请求包含</p> <ul><li><ol><li>请求方法-URL-协议/版本</li></ol></li> <li><ol start="2"><li>请求头</li></ol></li> <li><ol start="3"><li>请求正文</li></ol></li></ul></li> <li><p>http响应的请求包含</p> <ul><li><ol><li>状态行HTTP-Version Status-Code Reason-Phrase CRLF</li></ol></li> <li><ol start="2"><li>响应头</li></ol></li> <li><ol start="3"><li>响应正文</li></ol></li></ul></li></ul> <h2 id="http-1-0-1-1-2-0-3-0的特点及其区别"><a href="#http-1-0-1-1-2-0-3-0的特点及其区别" class="header-anchor">#</a> http 1.0 1.1 2.0 3.0的特点及其区别</h2> <ul><li><p>HTTP 1.0</p> <ul><li>短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能</li> <li>无host头域，也就是http请求头里的host，</li> <li>不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象</li></ul></li> <li><p>HTTP 1.1</p> <ul><li>长连接，流水线，使用connection:keep-alive使用长连接，与http 2.0不同的是， host头域由于长连接会给服务器造成压力</li></ul></li> <li><p>HTTP 2.0</p> <ul><li>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小</li> <li>多路复用，使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求</li> <li>可以使用服务端推送</li></ul></li> <li><p>HTTP 3.0</p> <ul><li>基于google的QUIC协议，而quic协议是使用udp实现的</li> <li>减少了tcp三次握手时间，以及tls握手时间</li> <li>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题</li> <li>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗</li> <li>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接</li> <li>更合适的流量控制</li></ul></li></ul> <h2 id="http请求头中各字段解释"><a href="#http请求头中各字段解释" class="header-anchor">#</a> HTTP请求头中各字段解释</h2> <ul><li><ol><li>Accept:可以接收的内容类型，例如text/plain</li></ol></li> <li><ol start="2"><li>Accept-Encoding:浏览器可以处理的编码方式，例如gzip, deflate, br</li></ol></li> <li><ol start="3"><li>Accept-Language:浏览器接收的语言，例如zh-CN</li></ol></li> <li><ol start="4"><li>Connection:告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。http1.1默认是keep-alive。</li></ol></li> <li><ol start="5"><li>Content-Length:一个请求的请求体的内存长度，单位为字节(byte)</li></ol></li> <li><ol start="6"><li>Content-Type:请求体中的内容的mime类型，通常只会用在POST和PUT方法的请求中。例如：application/x-www-form-urlencoded</li></ol></li> <li><ol start="7"><li>Cookie:浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie</li></ol></li> <li><ol start="8"><li>host:设置服务器域名和TCP端口号</li></ol></li> <li><ol start="9"><li>Referer:指当前请求的URL是在什么地址引用的</li></ol></li> <li><ol start="10"><li>User-Agent:用户的浏览器相关信息</li></ol></li></ul> <h2 id="tcp和udp的区别和优缺点"><a href="#tcp和udp的区别和优缺点" class="header-anchor">#</a> TCP和UDP的区别和优缺点</h2> <p>归为5点：连接、可靠性、实时性、交互方式、性能</p> <ul><li><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li></ol></li> <li><ol start="2"><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li></ol></li> <li><ol start="3"><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li></ol></li> <li><ol start="4"><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li></ol></li> <li><ol start="5"><li>TCP对系统资源要求较多，UDP对系统资源要求较少</li></ol></li></ul> <h2 id="tcp三次握手和四次挥手全过程及为什么要三次握手解答"><a href="#tcp三次握手和四次挥手全过程及为什么要三次握手解答" class="header-anchor">#</a> TCP三次握手和四次挥手全过程及为什么要三次握手解答</h2> <p><a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener noreferrer">参考文献<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>三次握手：</p> <p>SYN 的全称叫做 Synchronize Sequence Numbers，即&quot;同步序列号&quot;</p> <ul><li><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p></li> <li><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p></li> <li><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p> <p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
确认号：其数值等于发送方的发送序号+1(即接收方期望接收的下一个序列号)。</p></li></ul> <p>四次挥手：</p> <p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。</p> <ul><li><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</p></li> <li><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p></li> <li><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p></li> <li><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p> <p>TCP的四次挥手过程（简言之）：主动关闭方向被动关闭方发送不会再给你发数据了的信息；被动关闭方对收到的主动关闭方的报文段进行确认；被动关闭方向主动关闭方发送我也不会再给你发数据了的信息；主动关闭方再次对被动关闭方的确认进行确认。</p></li></ul> <h2 id="为什么不能两次握手-防止已失效的连接请求又传送到服务器端-因而产生错误"><a href="#为什么不能两次握手-防止已失效的连接请求又传送到服务器端-因而产生错误" class="header-anchor">#</a> 为什么不能两次握手：防止已失效的连接请求又传送到服务器端，因而产生错误</h2> <p>假设改为两次握手，client端发送的一个连接请求在服务器滞留了，这个连接请求是无效的，client已经是closed的状态了，而服务器认为client想要建立
一个新的连接，于是向client发送确认报文段，而client端是closed状态，无论收到什么报文都会丢弃。而如果是两次握手的话，此时就已经建立连接了。
服务器此时会一直等到client端发来数据，这样就浪费掉很多server端的资源。</p> <p>为什么要四次挥手：
关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，我们也未必全部数据都发送给对方了，所以我们不可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，我们的ACK和FIN一般都会分开发送。</p> <h2 id="syn攻击"><a href="#syn攻击" class="header-anchor">#</a> SYN攻击：</h2> <p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p> <h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="header-anchor">#</a> Cookie 和 Session 的区别：</h2> <ul><li><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li></ol></li> <li><ol start="2"><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储</li></ol></li> <li><ol start="3"><li>cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</li></ol></li> <li><ol start="4"><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</li></ol></li> <li><ol start="5"><li>所以：将登录信息等重要信息存放为session;其他信息如果需要保留，可以放在cookie中</li></ol></li></ul> <h2 id="osi七层协议模型、tcp-ip四层模型"><a href="#osi七层协议模型、tcp-ip四层模型" class="header-anchor">#</a> OSI七层协议模型、TCP/IP四层模型</h2> <ul><li>七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。七层结构记忆方法：应、表、会、传、网、数、物</li> <li>TCP/IP四层模型：应用层、传输层、网络层、数据链路层</li></ul> <h2 id="afnetworking-底层原理分析"><a href="#afnetworking-底层原理分析" class="header-anchor">#</a> AFNetworking 底层原理分析</h2> <p>AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:</p> <ul><li><ol><li>AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)</li></ol></li> <li><ol start="2"><li>AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。</li></ol></li> <li><ol start="3"><li>AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。</li></ol></li> <li><ol start="4"><li>AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。</li></ol></li> <li><ol start="5"><li>AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多。</li></ol></li> <li><ol start="6"><li>AFURLResponseSerialization：反序列化工具类;基类.使用比较多:</li></ol></li> <li><ol start="7"><li>AFJSONResponseSerializer; JSON解析器,默认的解析器.</li></ol></li> <li><ol start="8"><li>AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理.</li></ol></li> <li><ol start="9"><li>AFXMLParserResponseSerializer; XML解析器;</li></ol></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/iOS/Interview/结构体.html" class="prev">
        结构体
      </a></span> <span class="next"><a href="/notes/iOS/Interview/逆向.html">
        逆向
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d120e625.js" defer></script><script src="/assets/js/2.4ddb53c8.js" defer></script><script src="/assets/js/24.ed65da7c.js" defer></script>
  </body>
</html>
