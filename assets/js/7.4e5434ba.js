(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{396:function(t,a,i){t.exports=i.p+"assets/img/isa.2cd0aa37.png"},412:function(t,a,i){"use strict";i.r(a);var e=i(55),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" Runtime")]),t._v(" "),e("h2",{attrs:{id:"runtime具体应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime具体应用"}},[t._v("#")]),t._v(" runtime具体应用")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("利用关联对象（AssociatedObject）给分类添加属性")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("遍历类的所有成员变量（字典转模型、自动归档解档）")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("交换方法实现（交换系统的方法）")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("利用消息转发机制解决方法找不到的异常问题")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("A/B Test方案")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"6"}},[e("li",[t._v("无痕埋点")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"7"}},[e("li",[t._v("CTMediator组件化")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"8"}},[e("li",[t._v("内存泄漏检测原理")])])])]),t._v(" "),e("h2",{attrs:{id:"isa指针的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#isa指针的理解"}},[t._v("#")]),t._v(" isa指针的理解")]),t._v(" "),e("p",[e("img",{attrs:{src:i(396),alt:"isa"}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("isa 等价于 is kind of")]),t._v(" "),e("p",[t._v("实例对象的 isa 指向类对象")]),t._v(" "),e("p",[t._v("类对象的 isa 指向元类对象")]),t._v(" "),e("p",[t._v("元类对象的 isa 指向元类的基类")])])]),t._v(" "),e("h2",{attrs:{id:"为什么分类中不能创建属性property"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么分类中不能创建属性property"}},[t._v("#")]),t._v(" 为什么分类中不能创建属性Property?")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法倒叙插入到类对象的方法列表最前面。所以不同的Category，添加了同一个方法，执行的实际上是最后一个。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("Category可以添加属性，但是并不会自动生成成员变量及set/get方法。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的，那么我们就无法在程序运行时将分类的成员变量中添加到实例对象的结构体中，因此分类中不可以添加成员变量。")])])])]),t._v(" "),e("h2",{attrs:{id:"自动释放池原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动释放池原理"}},[t._v("#")]),t._v(" 自动释放池原理")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/7bd2f85f03dc",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文献"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("在当次runloop将要结束的时候调用objc_autoreleasePoolPop，并push进来一个新的AutoreleasePool")]),t._v(" "),e("h2",{attrs:{id:"消息转发机制原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息转发机制原理"}},[t._v("#")]),t._v(" 消息转发机制原理？")]),t._v(" "),e("p",[t._v("消息转发机制基本分为三个步骤：")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("动态方法解析：调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("快速转发：调用forwardingTargetForSelector，把这个消息转发给其他对象")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("慢速转发：发送-methodSignatureForSelector:消息获得函数的参数和返回值类型")])]),t._v(" "),e("ul",[e("li",[t._v("a. 返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。")]),t._v(" "),e("li",[t._v("b. 返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象")])])])]),t._v(" "),e("h2",{attrs:{id:"objc在向一个对象发送消息时-发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objc在向一个对象发送消息时-发生了什么"}},[t._v("#")]),t._v(" objc在向一个对象发送消息时，发生了什么")]),t._v(" "),e("p",[t._v("根据对象的isa指针找到类对象id，再查询类对象里面的methodLists方法函数列表，如果没有找到，在沿着superClass,寻找父类，再在父类methodLists方法列表里面查询，最终找到SEL,根据id和SEL确认IMP（指针函数）,再发送消息；")]),t._v(" "),e("h2",{attrs:{id:"load-和-initilze-的调用情况-以及子类的调用顺序问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#load-和-initilze-的调用情况-以及子类的调用顺序问题"}},[t._v("#")]),t._v(" load 和 initilze 的调用情况，以及子类的调用顺序问题")]),t._v(" "),e("p",[t._v("load")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("load当程序被加载的时候就会调用，其加载顺序为：如果子类实现类load，先执行父类 -> 再执行子类，而分类的在最后执行。如果子类不实现load，父类的load就不会被执行。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("当有多个类的时候，每个类的load的执行顺序和编译顺序一致")])])])]),t._v(" "),e("p",[t._v("initilze")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("initialize 这个方法是第一次给某给类发送消息的时候调用，并且只会调用一次。 如果某一个类一直没有被用到，此方法也不会执行。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("initialize先初始化父类， 在初始化子类，子类的initialize 会覆盖父类的方法。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("分类中实现了initialize会覆盖本来的initialize方法，如果多个分类都执行了initialize ，那么只是执行最后编译的那个。")])])])]),t._v(" "),e("h2",{attrs:{id:"kvo内部实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kvo内部实现原理"}},[t._v("#")]),t._v(" KVO内部实现原理")]),t._v(" "),e("p",[t._v("KVO是基于runtime机制实现的。\n当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制")]),t._v(" "),e("p",[t._v("如果原类为Person，那么生成的派生类名为NSKVONotifying_Person")]),t._v(" "),e("p",[t._v("每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法")]),t._v(" "),e("p",[t._v("键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。")]),t._v(" "),e("h2",{attrs:{id:"kvc原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kvc原理"}},[t._v("#")]),t._v(" KVC原理")]),t._v(" "),e("p",[t._v("KVC主要通过isa-swizzling（类型混合指针机制）, 来实现其内部查找定位的。具体主要分为三大步")]),t._v(" "),e("ul",[e("li",[t._v("第一步：寻找该属性有没有setter方法？有，就直接赋值")]),t._v(" "),e("li",[t._v("第二步：寻找有没有该属性带下划线的成员属性？有，就直接赋值")]),t._v(" "),e("li",[t._v("第三步：寻找有没有该属性的成员属性？有，就直接赋值")])]),t._v(" "),e("h2",{attrs:{id:"怎么理解objective-c是动态运行时语言。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么理解objective-c是动态运行时语言。"}},[t._v("#")]),t._v(" 怎么理解Objective-C是动态运行时语言。")]),t._v(" "),e("p",[t._v("主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。")]),t._v(" "),e("p",[t._v("运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。")]),t._v(" "),e("p",[t._v("多态:不同对象以自己的方式响应相同的消息的能力叫做多态。")])])}),[],!1,null,null,null);a.default=r.exports}}]);