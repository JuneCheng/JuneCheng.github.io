(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{420:function(t,a,s){"use strict";s.r(a);var e=s(55),l=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[t._v("#")]),t._v(" 底层原理")]),t._v(" "),s("h2",{attrs:{id:"类与元类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类与元类"}},[t._v("#")]),t._v(" 类与元类")]),t._v(" "),s("p",[t._v("[参考文献][https://www.jianshu.com/p/51b4019a8df2]")]),t._v(" "),s("p",[t._v("每个对象都有一个类，对象的类是isa指针决定的，即 isa 指针指向对象所属的类。")]),t._v(" "),s("p",[t._v("当你给对象发送消息时，消息是在寻找这个对象的类的方法列表。")]),t._v(" "),s("p",[t._v("当你给类发消息时，消息是在寻找这个类的元类的方法列表。")]),t._v(" "),s("p",[t._v("所有的元类都使用根元类作为他们的类。这就意味着所有NSObject的子类（大多数类）的元类都会以NSObject的元类作为他们的类，根元类的 isa 指针指向了它自己")]),t._v(" "),s("h2",{attrs:{id:"dealloc中做了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dealloc中做了什么"}},[t._v("#")]),t._v(" dealloc中做了什么")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("_objc_rootDealloc()")])])]),t._v(" "),s("li",[t._v("2.rootDealloc()\n"),s("ul",[s("li",[t._v("2.1首先判断 isTaggedPointer 是否是标记指针 是直接 return")]),t._v(" "),s("li",[t._v("2.2判断(优化过isa指针&&不存在弱引用指向&&没设置过关联对象&&没有c++的析构函数&&不存在引用计数器是否过大无法存储在isa中),快速释放，否则进入下一阶段")])])]),t._v(" "),s("li",[t._v("3.object_dispose()\n"),s("ul",[s("li",[t._v("3.1调用objc_destructInstance，析构函数中成员变量释放&关联对象的释放&弱引用表清空&引用计数表清空")]),t._v(" "),s("li",[t._v("3.2释放自己")])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);