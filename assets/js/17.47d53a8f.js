(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{415:function(e,t,i){"use strict";i.r(t);var v=i(55),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"ui视图"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ui视图"}},[e._v("#")]),e._v(" UI视图")]),e._v(" "),i("h2",{attrs:{id:"_1-uiview-uilayer区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-uiview-uilayer区别"}},[e._v("#")]),e._v(" 1.UIView UIlayer区别")]),e._v(" "),i("ul",[i("li",[i("ol",[i("li",[e._v("每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint")])])]),e._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[e._v("在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 来绘制和显示")])])]),e._v(" "),i("li",[i("ol",{attrs:{start:"3"}},[i("li",[e._v("CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)")])])]),e._v(" "),i("li",[i("ol",{attrs:{start:"4"}},[i("li",[e._v("两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以")])])])]),e._v(" "),i("h2",{attrs:{id:"_2-frame和bounds有什么不同"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-frame和bounds有什么不同"}},[e._v("#")]),e._v(" 2.frame和bounds有什么不同？")]),e._v(" "),i("ul",[i("li",[e._v("frame指的是该view在父view坐标系统中的位置和大小。（参照物是他的父坐标系统）。")]),e._v(" "),i("li",[e._v("bounds指的是该view在他本身的坐标系统中的位置和大小。（参照点是本身的坐标系统）。")])]),e._v(" "),i("h2",{attrs:{id:"_3-事件传递机制"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件传递机制"}},[e._v("#")]),e._v(" 3.事件传递机制")]),e._v(" "),i("ul",[i("li",[e._v("点击屏幕->UIApplication->UIWindow（通过hitTest:withEvent:和pointInside:withEvent:方法判断view是否响应此事件）")]),e._v(" "),i("li",[e._v("如果该view能响应此事件，倒序遍历该view的子视图能否响应此事件，如果子视图都不能响应，则返回该view是最佳响应者")])]),e._v(" "),i("h2",{attrs:{id:"_4-如何扩大view的响应范围"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何扩大view的响应范围"}},[e._v("#")]),e._v(" 4.如何扩大view的响应范围")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("给UIButton 建立一个Category --UIButton+EnlargeEdge.h，利用 objective-c 中的 objc_setAssociatedObject 来记录要变大的范围。objc_setAssociatedObject 是 objective-c runtime library 里面的 function。需要#import <objc/runtime.h>")])]),e._v(" "),i("li",[i("p",[e._v("最后，最重要的是去 override - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent)event\n用新设定的 Rect 来当着点击范围。")])])]),e._v(" "),i("h2",{attrs:{id:"_5-uiapplication父类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5-uiapplication父类"}},[e._v("#")]),e._v(" 5.UIApplication父类")]),e._v(" "),i("p",[e._v("UIResponder")]),e._v(" "),i("h2",{attrs:{id:"_6-uitouch-uievent"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_6-uitouch-uievent"}},[e._v("#")]),e._v(" 6.UITouch UIEvent")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("UIEvent")]),e._v(" "),i("p",[e._v("当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象。")]),e._v(" "),i("p",[e._v("一根手指对应一个UITouch对象")]),e._v(" "),i("p",[e._v("UITouch的作用")]),e._v(" "),i("ul",[i("li",[e._v("保存着跟手指相关的信息，比如触摸的位置、时间、阶段")]),e._v(" "),i("li",[e._v("当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置")]),e._v(" "),i("li",[e._v("当手指离开屏幕时，系统会销毁相应的UITouch对象")])]),e._v(" "),i("p",[e._v("提示：iPhone开发中，要避免使用双击事件！")])]),e._v(" "),i("li",[i("p",[e._v("UIEvent")]),e._v(" "),i("p",[e._v("每产生一个事件，就会产生一个UIEvent对象")]),e._v(" "),i("p",[e._v("UIEvent：称为事件对象，记录事件产生的时刻和类型")]),e._v(" "),i("ul",[i("li",[e._v("触摸开始：- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event")]),e._v(" "),i("li",[e._v("触摸移动：- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event")]),e._v(" "),i("li",[e._v("触摸结束：- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event")]),e._v(" "),i("li",[e._v("触摸取消：- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event")])])])]),e._v(" "),i("h2",{attrs:{id:"_7-如何绘制uiview"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何绘制uiview"}},[e._v("#")]),e._v(" 7.如何绘制UIView")]),e._v(" "),i("p",[e._v("子类化一个UIView并重载drawRect:方法")])])}),[],!1,null,null,null);t.default=a.exports}}]);