(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{414:function(t,s,n){"use strict";n.r(s);var a=n(55),o=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"runloop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[t._v("#")]),t._v(" Runloop")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/u013480070/article/details/100154619",target:"_blank",rel:"noopener noreferrer"}},[t._v("runloop详解"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"runloop在项目中的应用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop在项目中的应用"}},[t._v("#")]),t._v(" runloop在项目中的应用")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/69c8e3889c27",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文献"),n("OutboundLink")],1)]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[t._v("优化定时器NSTimer，将timer标记为CommonMode")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[t._v("子线程的保活，创建一个子线程并添加NSPort")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"3"}},[n("li",[t._v("发现和消除卡顿,用到的是CFRunLoopObserverRef，可以监听RunLoop的各个状态，利用这一点可以检测出RunLoop 在进入睡眠之前和唤醒后的两个状态的耗时。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"4"}},[n("li",[t._v("全局异常捕获后，可以保证程序继续运行。原理是使用异常捕捉回调获取到崩溃的相关信息，然后获取当前runloop，并执行所有Mode")])])])]),t._v(" "),n("h2",{attrs:{id:"runloop是来做什么的-runloop和线程有什么关系-主线程默认开启了runloop么-子线程呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop是来做什么的-runloop和线程有什么关系-主线程默认开启了runloop么-子线程呢"}},[t._v("#")]),t._v(" runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？")]),t._v(" "),n("p",[t._v("runloop:字面意思就是运行循环，用来处理线程里面的事件和消息，其实质是一个do-While循环。")]),t._v(" "),n("p",[t._v("runloop和线程的关系：一个线程对应一个 runloop，每个线程如果想继续运行，不被释放，就必须有一个runloop来不停的跑圈，以来处理线程里面的各个事件和消息。Runloop 存储在一个全局的可变字典里，线程是 key ，Runloop 是 value。")]),t._v(" "),n("p",[t._v("主线程默认是开启一个runloop。也就是这个runloop才能保证我们程序正常的运行。子线程是默认没有开始")]),t._v(" "),n("h2",{attrs:{id:"nstimer在uiscrollview滑动时停止工作的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nstimer在uiscrollview滑动时停止工作的问题"}},[t._v("#")]),t._v(" NSTimer在UIScrollView滑动时停止工作的问题")]),t._v(" "),n("p",[t._v("这是因为RunLoop同一时间，只能运行一种模式。在滚动时，系统为了保证操作的流畅性，会自动将默认模式(kCFRunLoopDefaultMode)切换成界面跟踪模式(UITrackingRunLoopMode)，在该模式下，定时器就会停止。当不再滚动时，定时器会重新开始工作。")]),t._v(" "),n("p",[t._v("解决方案：")]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[t._v("将Timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[t._v("将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰")])])])]),t._v(" "),n("h2",{attrs:{id:"子线程中nstimer不走或者子线程中不能执行任务performselector-onthread-withobject-waituntildone-原因是子线程是默认没有开启runroop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#子线程中nstimer不走或者子线程中不能执行任务performselector-onthread-withobject-waituntildone-原因是子线程是默认没有开启runroop"}},[t._v("#")]),t._v(" 子线程中NSTimer不走或者子线程中不能执行任务performSelector:onThread:withObject:waitUntilDone:原因是子线程是默认没有开启runroop")]),t._v(" "),n("div",{staticClass:"language-objc line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-objc"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 添加Timer, 开启RunLoop")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSRunLoop currentRunLoop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" addTimer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("timers"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("_indexPath"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" forMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSRunLoopCommonModes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或者添加NSPort,开启 RunLoop")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSRunLoop currentRunLoop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" addPort"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSPort port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" forMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSRunLoopCommonModes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br")])]),n("h2",{attrs:{id:"cadispalytimer和timer哪个更精确"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cadispalytimer和timer哪个更精确"}},[t._v("#")]),t._v(" CADispalyTimer和Timer哪个更精确")]),t._v(" "),n("p",[t._v("iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。")]),t._v(" "),n("p",[t._v("NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。")]),t._v(" "),n("p",[t._v("CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。")]),t._v(" "),n("h2",{attrs:{id:"runloop的运行模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop的运行模式"}},[t._v("#")]),t._v(" RunLoop的运行模式")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重写启动一个运行模式")]),t._v(" "),n("div",{staticClass:"language-objc line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-objc"}},[n("code",[n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" kCFRunLoopDefaultMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" App的默认运行模式，通常主线程是在这个运行模式下运行\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" UITrackingRunLoopMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" kCFRunLoopCommonModes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 伪模式，不是一种真正的运行模式\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" UIInitializationRunLoopMode：在刚启动App时第进入的第一个Mode，启动完成后就不再使用\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br")])])])]),t._v(" "),n("h2",{attrs:{id:"runloop数据结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop数据结构"}},[t._v("#")]),t._v(" RunLoop数据结构")]),t._v(" "),n("p",[t._v("线程和RunLoop一一对应， RunLoop和Mode是一对多的，Mode和source、timer、observer也是一对多的，具体如下")]),t._v(" "),n("div",{staticClass:"language-objc line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-objc"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" __CFRunLoop "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    pthread_t _pthread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//线程")]),t._v("\n    CFMutableSetRef _commonModes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// commonModes下的两个mode（kCFRunloopDefaultMode和UITrackingMode）")]),t._v("\n    CFMutableSetRef _commonModeItems"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在commonModes状态下运行的对象（例如Timer）")]),t._v("\n    CFMutableSetRef _modes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("           "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 运行的所有模式（CFRunloopModeRef类）")]),t._v("\n    CFRunLoopModeRef _currentMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在当前loop下运行的mode")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" __CFRunLoopMode "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    CFStringRef _name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// Mode Name, 例如 @"kCFRunLoopDefaultMode"')]),t._v("\n    CFMutableSetRef _sources0"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set")]),t._v("\n    CFMutableSetRef _sources1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set")]),t._v("\n    CFMutableArrayRef _observers"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Array")]),t._v("\n    CFMutableArrayRef _timers"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Array")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br")])]),n("h2",{attrs:{id:"runloop与gcd"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runloop与gcd"}},[t._v("#")]),t._v(" runloop与GCD")]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[t._v("runLoop 的超时时间就是使用 GCD 中的 dispatch_source_t来实现的")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[t._v("执行GCD MainQueue(主队列) 上的异步任务")])]),t._v(" "),n("p",[t._v("GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。")])])]),t._v(" "),n("p",[t._v("实现机制：")]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[t._v("通知观察者：RunLoop 即将启动。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"2"}},[n("li",[t._v("通知观察者：将要处理Timer事件。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"3"}},[n("li",[t._v("通知观察者：将要处理source0事件。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"4"}},[n("li",[t._v("处理source0事件。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"5"}},[n("li",[t._v("如果有source1事件，进入步骤9。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"6"}},[n("li",[t._v("通知观察者：线程即将休眠。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"7"}},[n("li",[t._v("将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。")])]),t._v(" "),n("ul",[n("li",[t._v("一个基于 port 的Source1 的事件(图里应该是source0)。")]),t._v(" "),n("li",[t._v("一个 Timer 到时间了。")]),t._v(" "),n("li",[t._v("RunLoop 自身的超时时间到了。")]),t._v(" "),n("li",[t._v("被其他调用者手动唤醒。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"8"}},[n("li",[t._v("通知观察者：线程将被唤醒。")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"9"}},[n("li",[t._v("处理唤醒时收到的事件。")])]),t._v(" "),n("ul",[n("li",[t._v("如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。")]),t._v(" "),n("li",[t._v("如果输入源启动，传递相应的消息。")]),t._v(" "),n("li",[t._v("如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2")])])]),t._v(" "),n("li",[n("ol",{attrs:{start:"10"}},[n("li",[t._v("通知观察者：RunLoop即将结束。")])])])]),t._v(" "),n("p",[t._v("source0与source1：")]),t._v(" "),n("ul",[n("li",[t._v("source0：包括 触摸事件处理、[performSelector: onThread: ]")]),t._v(" "),n("li",[t._v("source1：包括 基于Port的线程间通信、系统事件捕捉")])])])}),[],!1,null,null,null);s.default=o.exports}}]);