(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{416:function(a,t,e){"use strict";e.r(t);var r=e(55),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"三方库相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三方库相关"}},[a._v("#")]),a._v(" 三方库相关")]),a._v(" "),e("h2",{attrs:{id:"sdwebimage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sdwebimage"}},[a._v("#")]),a._v(" SDWebImage")]),a._v(" "),e("h3",{attrs:{id:"sdwebimage清除缓存机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sdwebimage清除缓存机制"}},[a._v("#")]),a._v(" SDWebImage清除缓存机制")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/ff9095de1753?utm_source=desktop&utm_medium=timeline",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考文献"),e("OutboundLink")],1),a._v("\nSDImageCache init初始化的时候注册了3个通知")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("程序收到内存警告的时候就会清除内存警告")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("程序结束的时候清除磁盘中缓存时间超过7天的文件")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("还有就是在程序进入后台的时候，也会自动的去清理缓存期限超过7天的文件")])])])]),a._v(" "),e("h2",{attrs:{id:"mleakfinder原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mleakfinder原理"}},[a._v("#")]),a._v(" MLeakFinder原理")]),a._v(" "),e("h3",{attrs:{id:"mleakfinder原理-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mleakfinder原理-2"}},[a._v("#")]),a._v(" MLeakFinder原理")]),a._v(" "),e("p",[a._v("对将要释放的对象，延迟2s在主线程调用一个方法，如果2s内，对象释放，则对nil进行消息发送也是安全的，如果2s内，对象没有释放，那么进行输出，该对象没有释放！，并打印相关信息。")]),a._v(" "),e("h2",{attrs:{id:"ctmediator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ctmediator"}},[a._v("#")]),a._v(" CTMediator")]),a._v(" "),e("h3",{attrs:{id:"ctmediator组件化原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ctmediator组件化原理"}},[a._v("#")]),a._v(" CTMediator组件化原理")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/zhou--fei/p/10306657.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考文献"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("CTMediator按照功能的结构来讲，使用时需要实现CTMediator的三部分。")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("CTMediator类：承担总枢纽，总调度的责任")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("Target_(ModuleName)类：承担组件对外暴漏接口功能，组件要提供什么服务，主要在它的接口声明上进行体现")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("CTMediator+(ModuleName)分类：主要供客户端使用，里面声明了可以调用的组件接口。")])])])]),a._v(" "),e("p",[a._v("CTMediator主要采用target-action的方式实现组件间解耦合，本身功能完全独立，不依赖任何组件模块。")]),a._v(" "),e("p",[a._v("主要实现方案分两种情况：")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("首先利用runtime进行反射，将类字符串和方法字符串转换成类和SEL方法选择子，然后调用[target performSelector:action withObject:params];")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("使用cocoa touch提供的命令模式，将消息和消息接受者封装成一个对象，进行执行。\n首先，利用target-action生成方法签名\n然后，创建NSInvocation对象，进行执行invoke。并拿到返回的结果。")])])])]),a._v(" "),e("p",[a._v("CTMediator的优点：")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("方便传递各种类型的参数。")])])])]),a._v(" "),e("h2",{attrs:{id:"cordova"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cordova"}},[a._v("#")]),a._v(" Cordova")]),a._v(" "),e("h3",{attrs:{id:"cordova原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cordova原理"}},[a._v("#")]),a._v(" Cordova原理")]),a._v(" "),e("p",[a._v("JS通过cordova.js类中的cordova.exec(successCallback, failCallback, service, action, actionArgs)方法调用，传进来的这五个参数并不会直接传给原生，cordova.js会先做这样的处理：")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("为每个请求生成一个叫 callbackId 的唯一标识：这个参数需传给 Objective-C 端，Objective-C 处理完后，会把 callbackId 连同处理结果一起返回给 JS 端")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("以 callbackId 为 key，{success:successCallback, fail:failCallback} 为 value，把这个键值对保存在 JS 端的字典里，successCallback 与 failCallback 这两个参数不需要传给 Objective-C 端，Objective-C 返回结果时带上 callbackId，JS 端就可以根据 callbackId 找到回调方法")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("每次 JS 请求，最后发到 Objective-C 的数据包括：callbackId, service, action, actionArgs")])])])]),a._v(" "),e("p",[a._v("iOS端是通过原生的webview中进行拦截，拿到callbackId, service, action, actionArgs后，会做以下的处理：")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("根据 service 参数找到对应的插件类")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("根据 action 参数找到插件类中对应的处理方法，并把 actionArgs 作为处理方法请求参数的一部分传给处理方法")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("处理完成后，把处理结果及 callbackId 返回给 JS 端，JS 端收到后会根据 callbackId 找到回调方法，并把处理结果传给回调方法")])])])]),a._v(" "),e("h2",{attrs:{id:"jspatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jspatch"}},[a._v("#")]),a._v(" JSPatch")]),a._v(" "),e("h3",{attrs:{id:"jspatch原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jspatch原理"}},[a._v("#")]),a._v(" JSPatch原理")]),a._v(" "),e("p",[a._v("利用js与OC的交互来实现")])])}),[],!1,null,null,null);t.default=s.exports}}]);