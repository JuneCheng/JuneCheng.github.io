(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{417:function(t,a,i){"use strict";i.r(a);var _=i(55),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"多线程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),i("h2",{attrs:{id:"gcd底层实现理解"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gcd底层实现理解"}},[t._v("#")]),t._v(" GCD底层实现理解")]),t._v(" "),i("ul",[i("li",[i("ol",[i("li",[t._v("GCD的层次比线程高，其底层是利用多线程来实现的，苹果将线程交给了系统去管理，这样任务的管理和执行比起线程来更加高效。")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[t._v("使用者要做的是定义自己Task任务，然后将其放到合适的分发队列去执行。")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"3"}},[i("li",[t._v("GCD的本质是在操作系统层面提供并行调度的，这样任务的切换效率要远高于内核的切换效率，它的大部分功能是在运行库里实现的。")])])])]),t._v(" "),i("h2",{attrs:{id:"nsoperation-自定义"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation-自定义"}},[t._v("#")]),t._v(" NSOperation 自定义")]),t._v(" "),i("ul",[i("li",[t._v("自定义子类继承NSOperation.")]),t._v(" "),i("li",[t._v("重载 - (void)main函数")]),t._v(" "),i("li",[t._v("有两个子类：NSInvocationOperation 和 NSBlockOperation")])]),t._v(" "),i("h2",{attrs:{id:"gcd-nsoperation区别-性能"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gcd-nsoperation区别-性能"}},[t._v("#")]),t._v(" GCD NSOperation区别，性能")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("GCD 和 NSOperation 都是用于实现多线程")])]),t._v(" "),i("li",[i("p",[t._v("GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。")])]),t._v(" "),i("li",[i("p",[t._v("NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。")])])]),t._v(" "),i("h2",{attrs:{id:"gcd核心概念"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gcd核心概念"}},[t._v("#")]),t._v(" GCD核心概念")]),t._v(" "),i("ul",[i("li",[t._v("任务（block）和队列（queue）")])]),t._v(" "),i("h2",{attrs:{id:"gcd有哪些api"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gcd有哪些api"}},[t._v("#")]),t._v(" GCD有哪些Api")]),t._v(" "),i("ul",[i("li",[i("ol",[i("li",[t._v("GCD信号量：dispatch_semaphore")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[t._v("GCD队列组：dispatch_group")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"3"}},[i("li",[t._v("GCD一次性代码：dispatch_once")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"4"}},[i("li",[t._v("GCD延时执行方法：dispatch_after")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"5"}},[i("li",[t._v("GCD栅栏方法：dispatch_barrier_async")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"6"}},[i("li",[t._v("GCD异步：dispatch_async")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"7"}},[i("li",[t._v("GCD同步：dispatch_sync")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"8"}},[i("li",[t._v("GCD快速迭代：dispatch_apply")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"9"}},[i("li",[t._v("GCD定时器：dispatch_time")])])])]),t._v(" "),i("h2",{attrs:{id:"dispatch-barrier-async函数的作用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-barrier-async函数的作用"}},[t._v("#")]),t._v(" dispatch_barrier_async函数的作用")]),t._v(" "),i("ul",[i("li",[i("ol",[i("li",[t._v("实现高效率的数据库访问和文件访问")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[t._v("避免数据竞争")])])])]),t._v(" "),i("h2",{attrs:{id:"锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),i("ul",[i("li",[t._v("@synchronized")]),t._v(" "),i("li",[t._v("NSLock")]),t._v(" "),i("li",[t._v("NSCondition")]),t._v(" "),i("li",[t._v("NSConditionLock")]),t._v(" "),i("li",[t._v("NSRecursiveLock")]),t._v(" "),i("li",[t._v("pthread_mutex_t")]),t._v(" "),i("li",[t._v("OSSpinLock")]),t._v(" "),i("li",[t._v("dispatch_barrier_async")])]),t._v(" "),i("p",[t._v("NSLock性能上优于synchronized。synchronized会创建一个异常捕获handler和一些内部的锁。所以，使用@synchronized替换普通锁的代价是，你付出更多的时间消耗。")]),t._v(" "),i("h2",{attrs:{id:"死锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),i("p",[t._v("线程间相互等待造成死锁")]),t._v(" "),i("ul",[i("li",[t._v("在主队列任务中再向队列添加同步任务，就会造成死锁")]),t._v(" "),i("li",[t._v("在串行队列的任务中再向队列添加同步任务，就会造成死锁")])]),t._v(" "),i("p",[t._v("解决方法：")]),t._v(" "),i("ul",[i("li",[i("ol",[i("li",[t._v("可以用NSRecursiveLock或者@synchronized替代NSLock")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[t._v("使用GCD的栅栏函数")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"3"}},[i("li",[t._v("采用异步执行block")])])])]),t._v(" "),i("h2",{attrs:{id:"dispatch-barrier-async-底层实现"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-barrier-async-底层实现"}},[t._v("#")]),t._v(" dispatch_barrier_async 底层实现")]),t._v(" "),i("p",[i("a",{attrs:{href:"https://www.jianshu.com/p/e677617a1cde",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/e677617a1cde"),i("OutboundLink")],1)]),t._v(" "),i("ul",[i("li",[t._v("do_vtable 设定了标志位 DISPATCH_OBJ_BARRIER_BIT, 从队列中取出任务执行的时候遇见这个标志位立即停止, 会终止循环, 返回一个空的信号量, 然后调用 _dispatch_queue_push手动把这个任务添加进去")])]),t._v(" "),i("h2",{attrs:{id:"dispatch-once-的底层实现"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once-的底层实现"}},[t._v("#")]),t._v(" dispatch_once 的底层实现")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("第一次调用: 此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。")])]),t._v(" "),i("li",[i("p",[t._v("同一线程第二次调用: 由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。")])]),t._v(" "),i("li",[i("p",[t._v("多个线程同时调用: 由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);